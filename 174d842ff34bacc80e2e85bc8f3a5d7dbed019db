{
  "comments": [
    {
      "key": {
        "uuid": "7faddb67_f86c8f09",
        "filename": "libc/upstream-openbsd/lib/libc/gen/fnmatch.c",
        "patchSetId": 2
      },
      "lineNbr": 108,
      "author": {
        "id": 2936
      },
      "writtenOn": "2016-04-04T18:53:20Z",
      "side": 1,
      "message": "Wouldn\u0027t this only work for 1 and 2 byte characters?",
      "revId": "174d842ff34bacc80e2e85bc8f3a5d7dbed019db",
      "serverId": "1ec6b3db-b2c1-4fa4-84a2-4c7efe89ba71",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7faddb67_9e8ea376",
        "filename": "libc/upstream-openbsd/lib/libc/gen/fnmatch.c",
        "patchSetId": 2
      },
      "lineNbr": 108,
      "author": {
        "id": 5503
      },
      "writtenOn": "2016-04-05T13:48:57Z",
      "side": 1,
      "message": "It looks functional to me.  The UTF-8 spec says that the first octet starts with the number of one bits equal to the number of octets in the character and then a zero bit.  Each subsequent octet begins with the top bits being 10.  Here we mask off 0xc0 to ensure there are at least two octets.  Then we shift by one for the first octet and continue shifting, verifying the octet starts with bit pattern 10.",
      "parentUuid": "7faddb67_f86c8f09",
      "revId": "174d842ff34bacc80e2e85bc8f3a5d7dbed019db",
      "serverId": "1ec6b3db-b2c1-4fa4-84a2-4c7efe89ba71",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7faddb67_7e6de796",
        "filename": "libc/upstream-openbsd/lib/libc/gen/fnmatch.c",
        "patchSetId": 2
      },
      "lineNbr": 108,
      "author": {
        "id": 2936
      },
      "writtenOn": "2016-04-05T14:28:18Z",
      "side": 1,
      "message": "Oh, no you\u0027re right. For some reason I kept thinking this check would catch 0xd/0xe/0xf.",
      "parentUuid": "7faddb67_9e8ea376",
      "revId": "174d842ff34bacc80e2e85bc8f3a5d7dbed019db",
      "serverId": "1ec6b3db-b2c1-4fa4-84a2-4c7efe89ba71",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7faddb67_15a129aa",
        "filename": "libc/upstream-openbsd/lib/libc/gen/fnmatch.c",
        "patchSetId": 2
      },
      "lineNbr": 286,
      "author": {
        "id": 14515
      },
      "writtenOn": "2016-04-07T06:31:17Z",
      "side": 1,
      "message": "Does toupper and tolower work for uint32_t non-ascii set? Most likely its no-op: http://androidxref.com/6.0.1_r10/xref/bionic/libc/upstream-openbsd/lib/libc/gen/tolower_.c#52 \n\nThe case insensitive portion still will not work as expected for non-ascii but case sensitive match will work better than earlier. That being the case, need to decide if it\u0027s valuable to make this change or not.",
      "range": {
        "startLine": 286,
        "startChar": 26,
        "endLine": 286,
        "endChar": 28
      },
      "revId": "174d842ff34bacc80e2e85bc8f3a5d7dbed019db",
      "serverId": "1ec6b3db-b2c1-4fa4-84a2-4c7efe89ba71",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7faddb67_d85bc884",
        "filename": "libc/upstream-openbsd/lib/libc/gen/fnmatch.c",
        "patchSetId": 2
      },
      "lineNbr": 286,
      "author": {
        "id": 2936
      },
      "writtenOn": "2016-04-07T18:00:44Z",
      "side": 1,
      "message": "I think the point of this commit is to just not crash, as opposed to actually supporting the functionality. It is true that the comparisons are a no-op though.",
      "parentUuid": "7faddb67_15a129aa",
      "range": {
        "startLine": 286,
        "startChar": 26,
        "endLine": 286,
        "endChar": 28
      },
      "revId": "174d842ff34bacc80e2e85bc8f3a5d7dbed019db",
      "serverId": "1ec6b3db-b2c1-4fa4-84a2-4c7efe89ba71",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7faddb67_5e658bb4",
        "filename": "libc/upstream-openbsd/lib/libc/gen/fnmatch.c",
        "patchSetId": 2
      },
      "lineNbr": 318,
      "author": {
        "id": 5503
      },
      "writtenOn": "2016-04-05T14:14:48Z",
      "side": 1,
      "message": "Probably don\u0027t need utf8_inc here since **pattern is known to be an ascii backslash.",
      "revId": "174d842ff34bacc80e2e85bc8f3a5d7dbed019db",
      "serverId": "1ec6b3db-b2c1-4fa4-84a2-4c7efe89ba71",
      "unresolved": false
    }
  ]
}